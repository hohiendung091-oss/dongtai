1:  // === 初始化阶段 ===
2:  参数初始化(噪声阈值, 综合性能阈值_父节点, 委员会规模_k,
3:             冲突区块集初步验证阈值_ɑ_c, 非冲突区块集初步验证阈值_ɑ_n,
4:             冲突区块集最终共识阈值_β_c, 非冲突区块集最终共识阈值_β_n,
5:             最大验证尝试次数, 新区块最大父区块引用数, 高置信度父区块选择阈值); // 系统运行所需各类参数 [cite: 1]
6:  时间戳_t = 0;                                                              // 系统时间戳或轮次计数器
7:  全网父网关列表_PGL = [];                                                     // 经选举产生的父网关节点列表
8:  待初步验证区块集队列_PVBQ = [];                                               // 网关构建后，等待委员会初步验证的区块集
9:  待最终共识区块集队列_FCBQ = [];                                               // 通过初步验证，等待委员会最终共识投票的区块集
10: 验证失败待重试区块集队列_RBQ = [];                                             // 未通过验证但可重试的区块集
11: 当前系统轮次_CSR = 0;

12: WHILE (TRUE) DO                                                          // 系统主循环
13:     时间戳_t++;                                                              // 时间推进
14:     当前系统轮次_CSR++;                                                        // 轮次增加

15:     // --- 阶段1: 新设备注册 ---
16:     IF 有新设备M申请加入网络 THEN
17:         设备M的设备ID_DT = 分配唯一设备标识符();                             // 为新设备分配ID
18:         将设备M信息添加至网络(设备M);
19:     END IF

20:     // --- 阶段2: 抗干扰父节点网关选举 (周期性或事件触发) --- [cite: 1] (对应论文3.2节)
21:     IF 到达父节点网关选举时间(时间戳_t, 当前系统轮次_CSR) THEN
22:         // 临时父网关列表_TPGL = []
23:         // FOR EACH 网关 G_i IN 全网所有网关列表
24:         //   G_i.噪声因子_α = 计算噪声因子(G_i.当前噪声);                     // 根据实际噪声与阈值计算 [cite: 1]
25:         //   IF G_i.噪声因子_α > 0 THEN // 噪声未超标
26:         //     G_i.节点性能因子_β_raw = 计算节点性能因子(G_i.计算能力, G_i.存储能力); // [cite: 1]
27:         //     G_i.网络带宽因子_N_raw = 计算网络带宽因子(G_i.测试数据包大小, G_i.往返时间); // [cite: 1]
28:         //     G_i.投票成功率_K_raw = 计算投票成功率(G_i.上轮成功投票数, G_i.上轮总投票数); // [cite: 1]
29:         //     G_i.通信时延因子_L_raw = 计算通信时延因子(G_i.标准包大小, G_i.网络带宽因子_N_raw, G_i.平均处理时延); // [cite: 1]
30:         //     (对 G_i.节点性能因子_β_raw, G_i.网络带宽因子_N_raw, G_i.投票成功率_K_raw 进行正向归一化得到 β', N', K')
31:         //     (对 G_i.通信时延因子_L_raw 进行负向归一化得到 L')
32:         //     G_i.综合性能指标_Q = G_i.噪声因子_α * (权重_性能*β' + 权重_带宽*N' + 权重_投票*K' + 权重_时延*L'); // [cite: 1]
33:         //     IF G_i.综合性能指标_Q >= 综合性能阈值_父节点 THEN
34:         //       将 G_i 加入到 临时父网关列表_TPGL;
35:         //     END IF
36:         //   END IF
37:         // END FOR
38:         // 全网父网关列表_PGL = 临时父网关列表_TPGL;
39:         全网父网关列表_PGL = 执行抗干扰父节点选举(全网所有网关列表);             // 封装执行上述23-38行的选举逻辑 [cite: 1]
40:         Log("父节点网关选举完成，数量: " + Length(全网父网关列表_PGL));
41:     END IF

42:     // --- 阶段3: 数据收集与区块集构建 (由各网关执行) --- [cite: 1] (对应论文3.3节第一部分：数据收集与区块集构建)
43:     IF 到达数据收集间隔时间(时间戳_t) THEN                                    //类比LNLCA的交易发起阶段
44:         FOR EACH 网关 G IN 全网所有网关列表
45:             // 传感器节点将采集并初步处理的数据发送给其所属网关 G [cite: 1]
46:             接收到的传感器数据包列表 = G.从传感器收集数据();
47:             G.对数据进行签名验证和预处理();                               // 例如0/1型转L/H，连续型转L/M/H [cite: 1]
48:             // G 将预处理后的数据打包成区块集: 冲突区块集_CB 和 非冲突区块集_NCB
49:             // 区块集结构: { 区块头, 节点数据(交易列表), 元数据, 特有要素(被引用次数=0, 是否验证=FALSE, 区块信誉值=0, 初步验证状态=0) } [cite: 1]
50:             (新冲突区块集_CB, 新非冲突区块集_NCB) = G.构建冲突与非冲突区块集();
51:             IF 新冲突区块集_CB IS NOT NULL THEN
52:                 // 网关 G 对自己构建的冲突区块集_CB 进行异常监测状态处理，剔除异常数据 [cite: 1]
53:                 处理后冲突区块集_PCB = G.处理冲突区块集内异常状态(新冲突区块集_CB);
54:                 将 处理后冲突区块集_PCB 加入到 待初步验证区块集队列_PVBQ;
55:             END IF
56:             IF 新非冲突区块集_NCB IS NOT NULL THEN
57:                 将 新非冲突区块集_NCB 加入到 待初步验证区块集队列_PVBQ;
58:             END IF
59:         END FOR
60:     END IF

61:     // --- 阶段4: 区块集初步验证 (由父节点网关委员会执行) --- //类比LNLCA的交易验证阶段
62:     IF NOT IsEmpty(待初步验证区块集队列_PVBQ) THEN
63:         FOR EACH 区块集_B IN 待初步验证区块集队列_PVBQ
64:             区块集_B.已尝试验证次数 = (区块集_B.已尝试验证次数 OR 0) + 1;

65:             父节点网关委员会_PGC = 从全网父网关列表_PGL中随机挑选k个成员();    // [cite: 1]
66:             IF IsEmpty(父节点网关委员会_PGC) THEN
67:                 将 区块集_B 加入到 验证失败待重试区块集队列_RBQ;             // 无可用委员会，稍后重试
68:                 CONTINUE;
69:             END IF

70:             // 委员会成员进行初步评估 (例如基于历史数据、规则的快速检查)
71:             初步同意票数 = 0;
72:             FOR EACH 委员会成员_M IN 父节点网关委员会_PGC
73:                 IF 成员_M.初步评估同意该区块集(区块集_B) THEN           // 此步骤对应论文中“严格按照历史轮次数据”的隐含要求 [cite: 1]
74:                     初步同意票数++;
75:                 END IF
76:             END FOR

77:             // 判断是否通过初步验证 (这里使用简单票数，实际可结合LNLCA中响应权重等概念)
78:             当前初步验证阈值 = (区块集_B.类型 == "冲突") ? 冲突区块集初步验证阈值_ɑ_c : 非冲突区块集初步验证阈值_ɑ_n;
79:             IF (初步同意票数 / Length(父节点网关委员会_PGC)) >= 当前初步验证阈值 THEN
80:                 区块集_B.初步验证状态 = 1; // 标记为“待共识”
81:                 将 区块集_B 从 待初步验证区块集队列_PVBQ 中移除;
82:                 将 区块集_B 加入到 待最终共识区块集队列_FCBQ;
83:             ELSE
84:                 区块集_B.初步验证状态 = 0; // 保持“待验证”
85:                 将 区块集_B 从 待初步验证区块集队列_PVBQ 中移除;
86:                 IF 区块集_B.已尝试验证次数 < 最大验证尝试次数 THEN
87:                     将 区块集_B 加入到 验证失败待重试区块集队列_RBQ;
88:                 ELSE
89:                     丢弃区块集_B; Log("区块集 " + 区块集_B.ID + " 初步验证多次失败被丢弃");
90:                 END IF
91:             END IF
92:         END FOR
93:     END IF

94:     // --- 阶段5: 区块集最终共识投票与上链 (由父节点网关委员会执行) --- [cite: 1] (对应论文3.3节第二部分与LNLCA的交易共识阶段)
95:     IF NOT IsEmpty(待最终共识区块集队列_FCBQ) THEN
96:         FOR EACH 区块集_B IN 待最终共识区块集队列_FCBQ
97:             // 父节点网关委员会_PGC 已在该轮次前面对此区块集进行过初步验证时选定，可复用或重选以增加动态性
98:             // 为简化，此处假设复用之前选定的委员会_PGC 或按需重新获取 ParentGatewayCommittee_PGC
99:             IF IsEmpty(父节点网关委员会_PGC) THEN // 确保 PGC 存在
100:                父节点网关委员会_PGC = 从全网父网关列表_PGL中随机挑选k个成员();
101:                IF IsEmpty(父节点网关委员会_PGC) THEN
102:                   将 区块集_B 加入到 验证失败待重试区块集队列_RBQ; // 无法找到委员会执行最终共识
103:                   CONTINUE;
104:               END IF
105:            END IF

106:            // 委员会成员基于其综合性能 Q_m 进行置信度投票
107:            委员会投票详情列表 = [];
108:            FOR EACH 委员会成员_M IN 父节点网关委员会_PGC
109:                // 成员_M.综合性能指标_Q 是已知的
110:                单票结果 = 成员_M.计算对区块集的赞同票详情(区块集_B, 成员_M.综合性能指标_Q); // 返回{是否赞同, 权重贡献(即Q_m)} [cite: 1]
111:                将 单票结果 加入到 委员会投票详情列表;
112:            END FOR

113:            // 由主节点(如委员会中选一leader或区块集提出者)计算最终区块集置信度 [cite: 1]
114:            区块集_B.最终置信度 = 计算最终区块集置信度(区块集_B.类型, 委员会投票详情列表);
115:            //   对冲突区块集使用加权乘值法(需小心处理确保值合理)或加权平均法，对非冲突区块集使用累加赞同票归一化法 [cite: 1]

116:            当前最终共识阈值 = (区块集_B.类型 == "冲突") ? 冲突区块集最终共识阈值_β_c : 非冲突区块集最终共识阈值_β_n;
117:            IF 区块集_B.最终置信度 >= 当前最终共识阈值 THEN
118:                区块集_B.初步验证状态 = 2; // 标记为“已共识”
119:                区块集_B.特有要素.是否验证 = TRUE;
120:                区块集_B.特有要素.区块信誉值 = 区块集_B.最终置信度;

121:                // 为已共识区块集选择父区块并连接到DAG中 [cite: 1]
122:                合适父区块列表 = 从当前DAG中选择父区块(高置信度父区块选择阈值, 新区块最大父区块引用数);
123:                区块集_B.区块头.前置引用 = 获取哈希列表(合适父区块列表);
124:                // (可能需要重新计算区块集B的区块头哈希)
125:                增加父区块的被引用次数(合适父区块列表);

126:                将 区块集_B 添加到本地DAG账本;
127:                向全网其他父网关和云端服务器广播已共识的区块集_B;          // [cite: 1]
128:                // 其他父网关接收后更新其本地DAG，并通知其下属传感器节点 [cite: 1]
129:                // 云端服务器保存完整区块链 [cite: 1]
130:                Log("区块集 " + 区块集_B.ID + " 已达成共识并上链");
131:            ELSE
132:                区块集_B.初步验证状态 = 1; // 保持“待共识”状态或降级
133:                IF 区块集_B.已尝试验证次数 < 最大验证尝试次数 THEN
134:                    将 区块集_B 加入到 验证失败待重试区块集队列_RBQ; // 进行重试（可能从初步验证开始或仅重试最终共识）
135:                ELSE
136:                    丢弃区块集_B; Log("区块集 " + 区块集_B.ID + " 最终共识多次失败被丢弃"); // [cite: 1]
137:                END IF
138:            END IF
139:            将 区块集_B 从 待最终共识区块集队列_FCBQ 中移除;
140:        END FOR
141:    END IF

142:    // --- 阶段6: 处理上一轮未成功但可重试的区块集 ---
143:    IF NOT IsEmpty(验证失败待重试区块集队列_RBQ) THEN
144:        FOR EACH 区块集_B IN 验证失败待重试区块集队列_RBQ
145:            将 区块集_B 加入到 待初步验证区块集队列_PVBQ; // 重新进入初步验证流程
146:        END FOR
147:        清空验证失败待重试区块集队列_RBQ;
148:    END IF

149:    // --- 并行/周期性任务: 传感器节点本地进行轻量化区块管理 --- [cite: 1] (对应论文3.1节可终结区块)
150:    FOR EACH 传感器节点_S IN 全网传感器节点列表
151:        IF 到达传感器本地清理周期(传感器节点_S, 时间戳_t) THEN
152:            // 传感器_S 检查其本地存储的DAG区块
153:            // FOR EACH 本地区块_lb IN 传感器_S.本地DAG副本
154:            //   区块存在时长 = 当前时间 - 区块_lb.区块头.时间戳;
155:            //   IF 区块存在时长 > 可终结时长阈值 AND 区块_lb.特有要素.被引用次数 < 可终结被引用次数阈值 AND 区块_lb.特有要素.是否验证 == TRUE THEN
156:            //     标记 区块_lb 为可终结区块;
157:            //     从本地存储中移除 区块_lb 以释放空间; // [cite: 1]
158:            //   END IF
159:            // END FOR
160:            传感器_S.执行本地可终结区块清理机制(); // 封装执行153-159行的逻辑
161:        END IF
162:    END FOR

163:    // --- 系统轮次结束，准备下一轮 ---
164:    Log("系统轮次 " + 当前系统轮次_CSR + " 完成");
165:    等待下一轮开始(时间戳_t);
166: END WHILE